name: E2E (Minikube)

on:
  workflow_dispatch:
  pull_request:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: read

jobs:
  e2e:
    runs-on: ubuntu-latest
    env:
      NAMESPACE: llm-tutor

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: pip

      - name: Install test deps
        run: pip install -r requirements.txt

      - name: Setup Minikube
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          kubernetes-version: 'v1.29.0'
          driver: docker
          addons: ingress

      - name: Create namespace
        run: kubectl create namespace $NAMESPACE || true

      - name: GHCR pull secret (regcred)
        run: |
          kubectl -n $NAMESPACE create secret docker-registry regcred \
            --docker-server=ghcr.io \
            --docker-username=${{ secrets.GHCR_USERNAME || github.actor }} \
            --docker-password=${{ secrets.GHCR_PAT }} \
            --docker-email=edgardasilva10@hotmail.com \
            --dry-run=client -o yaml | kubectl apply -f -

      # Deploy RabbitMQ using official image (replaces Bitnami chart)
      - name: Deploy RabbitMQ (official image)
        run: |
          cat <<'YAML' | kubectl -n $NAMESPACE apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: rabbitmq
          spec:
            selector:
              app: rabbitmq
            ports:
              - name: amqp
                port: 5672
                targetPort: 5672
              - name: mgmt
                port: 15672
                targetPort: 15672
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: rabbitmq
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: rabbitmq
            template:
              metadata:
                labels:
                  app: rabbitmq
              spec:
                containers:
                  - name: rabbitmq
                    image: rabbitmq:3.13-management-alpine
                    ports:
                      - containerPort: 5672
                      - containerPort: 15672
                    env:
                      - name: RABBITMQ_DEFAULT_USER
                        value: "appuser"
                      - name: RABBITMQ_DEFAULT_PASS
                        value: "apppass"
                      - name: RABBITMQ_DEFAULT_VHOST
                        value: "/"
                      - name: RABBITMQ_URL
                        value: "amqp://appuser:apppass@rabbitmq:5672/%2F"
                    readinessProbe:
                      tcpSocket:
                        port: 5672
                      initialDelaySeconds: 10
                      periodSeconds: 5
                    livenessProbe:
                      tcpSocket:
                        port: 5672
                      initialDelaySeconds: 20
                      periodSeconds: 10
          YAML

      - name: Wait for RabbitMQ
        run: |
          kubectl -n $NAMESPACE rollout status deploy/rabbitmq --timeout=300s
          kubectl -n $NAMESPACE get svc rabbitmq

      - name: Deploy Postgres (ephemeral)
        run: |
          cat <<'YAML' | kubectl -n $NAMESPACE apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: postgres
          spec:
            selector:
              app: postgres
            ports:
              - port: 5432
                targetPort: 5432
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: postgres
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: postgres
            template:
              metadata:
                labels:
                  app: postgres
              spec:
                containers:
                  - name: postgres
                    image: pgvector/pgvector:pg16
                    env:
                      - name: POSTGRES_DB
                        value: "${{ secrets.DB_NAME }}"
                      - name: POSTGRES_PASSWORD
                        value: "${{ secrets.PG_PASSWORD }}"
                    ports:
                      - containerPort: 5432
                    readinessProbe:
                      tcpSocket: { port: 5432 }
                      initialDelaySeconds: 10
                      periodSeconds: 5
                    livenessProbe:
                      tcpSocket: { port: 5432 }
                      initialDelaySeconds: 20
                      periodSeconds: 10
          YAML

      - name: Wait for Postgres
        run: kubectl -n $NAMESPACE rollout status deploy/postgres --timeout=300s

      - name: Initialize application databases (Job)
        env:
          PGPASSWORD: ${{ secrets.PG_PASSWORD }}
        run: |
          # Create a one-shot Job to initialize databases reliably and wait for completion
          cat <<YAML | kubectl -n $NAMESPACE apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-init
          spec:
            backoffLimit: 2
            template:
              metadata:
                name: db-init
              spec:
                restartPolicy: Never
                containers:
                  - name: psql
                    image: pgvector/pgvector:pg16
                    env:
                      - name: PGPASSWORD
                        value: "${PGPASSWORD}"
                    command: ["sh","-lc"]
                    args:
                      - |
                        set -xe
                        until pg_isready -h postgres -p 5432 -U postgres; do echo "waiting for postgres"; sleep 2; done;
                        psql -h postgres -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c 'CREATE DATABASE "Users";' || echo "Users exists"
                        psql -h postgres -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c 'CREATE DATABASE "Evaluation";' || echo "Evaluation exists"
                        psql -h postgres -p 5432 -U postgres -d postgres -v ON_ERROR_STOP=1 -c 'CREATE DATABASE "Khan_Academy";' || echo "Khan_Academy exists"
                        psql -h postgres -p 5432 -U postgres -d "Khan_Academy" -v ON_ERROR_STOP=1 -c 'CREATE EXTENSION IF NOT EXISTS vector;'
                        echo "DBs ready:"
                        psql -h postgres -p 5432 -U postgres -d postgres -c '\l'
          YAML
          kubectl -n $NAMESPACE wait --for=condition=complete job/db-init --timeout=180s
          echo "db-init job logs:"
          kubectl -n $NAMESPACE logs job/db-init || true

      # Recommendation 1: print debug info if RabbitMQ fails
      - name: Debug RabbitMQ (on failure)
        if: failure()
        run: |
          kubectl -n $NAMESPACE get pods -o wide
          kubectl -n $NAMESPACE describe pod -l app=rabbitmq
          kubectl -n $NAMESPACE logs -l app=rabbitmq --tail=200

      - name: Apply config/secrets/ingress
        run: |
          kubectl -n $NAMESPACE apply -f k8s/app-config.yaml
          kubectl -n $NAMESPACE apply -f k8s/ingress-apis.yaml
          # Ensure DB_PORT is correct in ConfigMap before first pods start
          kubectl -n $NAMESPACE patch configmap app-config --type='merge' -p '{
            "data": { "DB_PORT": "5432" }
          }' || true

      - name: Create app-secrets from GitHub Secrets
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          PG_PASSWORD: ${{ secrets.PG_PASSWORD }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPIK_API_KEY: ${{ secrets.OPIK_API_KEY }}
          REDIS_ENDPOINT: ${{ secrets.REDIS_ENDPOINT }}
          REDIS_PORT: 10279
          REDIS_USERNAME: default
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          RABBITMQ_USER: ${{ secrets.RABBITMQ_USER }}
          RABBITMQ_PASS: ${{ secrets.RABBITMQ_PASS }}
          HOST: postgres
          USERNAME: postgres
        run: |
          kubectl -n $NAMESPACE create secret generic app-secrets \
            --from-literal=SECRET_KEY="$SECRET_KEY" \
            --from-literal=AUTH_SECRET="$AUTH_SECRET" \
            --from-literal=PG_PASSWORD="$PG_PASSWORD" \
            --from-literal=OPENAI_API_KEY="$OPENAI_API_KEY" \
            --from-literal=OPIK_API_KEY="$OPIK_API_KEY" \
            --from-literal=REDIS_ENDPOINT="$REDIS_ENDPOINT" \
            --from-literal=REDIS_PORT="$REDIS_PORT" \
            --from-literal=REDIS_USERNAME="$REDIS_USERNAME" \
            --from-literal=REDIS_PASSWORD="$REDIS_PASSWORD" \
            --from-literal=RABBITMQ_USER="$RABBITMQ_USER" \
            --from-literal=RABBITMQ_PASS="$RABBITMQ_PASS" \
            --from-literal=HOST="$HOST" \
            --from-literal=USERNAME="$USERNAME" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy services
        run: |
          kubectl -n $NAMESPACE apply -f k8s/auth.yaml
          kubectl -n $NAMESPACE apply -f k8s/quizz.yaml
          kubectl -n $NAMESPACE apply -f k8s/quiz-generator-consumer.yaml
          kubectl -n $NAMESPACE apply -f k8s/evaluation.yaml
          kubectl -n $NAMESPACE apply -f k8s/rag.yaml
        # Avoid applying CRDs/resources for KEDA in CI unless you install the operator
      
      - name: Force single replica for evaluation-service (first boot)
        run: |
          # Immediately ensure only one pod for evaluation-service to avoid concurrent DDL on first boot
          kubectl -n $NAMESPACE scale deploy/evaluation-service --replicas=1 || true
          kubectl -n $NAMESPACE rollout status deploy/evaluation-service --timeout=300s || true

      - name: CI rollout hardening (all services)
        run: |
          # Apply Recreate strategy to avoid RollingUpdate deadlocks in CI
          for d in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            kubectl -n $NAMESPACE patch deploy/$d --type='merge' -p '{
              "spec": { "strategy": { "type": "Recreate" } }
            }' || true
          done
          
          # Ensure DB_PORT is 5432 on all deployments
          for d in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            kubectl -n $NAMESPACE set env deploy/$d DB_PORT=5432 || true
          done
          
          # Clean restart: scale down to 0, force delete leftover pods, scale up to 1
          for d in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            kubectl -n $NAMESPACE scale deploy/$d --replicas=0 || true
          done
          
          kubectl -n $NAMESPACE delete pod -l app=auth-service --grace-period=0 --force || true
          kubectl -n $NAMESPACE delete pod -l app=quizz-service --grace-period=0 --force || true
          kubectl -n $NAMESPACE delete pod -l app=quiz-generator-consumer --grace-period=0 --force || true
          kubectl -n $NAMESPACE delete pod -l app=evaluation-service --grace-period=0 --force || true
          kubectl -n $NAMESPACE delete pod -l app=rag-service --grace-period=0 --force || true
          
          for d in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            kubectl -n $NAMESPACE scale deploy/$d --replicas=1 || true
          done

      - name: Standardize readiness probes
        run: |
          # Auth: use lightweight OpenAPI route (no auth) for readiness
          kubectl -n $NAMESPACE patch deploy/auth-service --type='json' -p='[
            {"op":"replace","path":"/spec/template/spec/containers/0/readinessProbe/httpGet/path","value":"/openapi.json"},
            {"op":"replace","path":"/spec/template/spec/containers/0/readinessProbe/initialDelaySeconds","value":60},
            {"op":"replace","path":"/spec/template/spec/containers/0/readinessProbe/periodSeconds","value":10},
            {"op":"replace","path":"/spec/template/spec/containers/0/readinessProbe/failureThreshold","value":12}
          ]' || true
          # Other services already expose /health; keep as-is

      - name: Wait for rollouts
        run: |
          kubectl -n $NAMESPACE rollout status deploy/auth-service --timeout=600s
          kubectl -n $NAMESPACE rollout status deploy/quizz-service --timeout=300s
          kubectl -n $NAMESPACE rollout status deploy/quiz-generator-consumer --timeout=300s
          kubectl -n $NAMESPACE rollout status deploy/evaluation-service --timeout=300s
          kubectl -n $NAMESPACE rollout status deploy/rag-service --timeout=300s

      - name: Seed E2E user via /auth/signup
        env:
          E2E_BASE_URL: ${{ env.E2E_BASE_URL }}
          E2E_USERNAME: ${{ secrets.E2E_USERNAME }}
          E2E_PASSWORD: ${{ secrets.E2E_PASSWORD }}
        run: |
          set -e
          echo "Seeding E2E user $E2E_USERNAME ..."
          for i in {1..30}; do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Content-Type: application/json" \
              -d "{\"username\":\"${E2E_USERNAME}\",\"email\":\"${E2E_USERNAME}@example.com\",\"full_name\":\"E2E User\",\"password\":\"${E2E_PASSWORD}\"}" \
              "${E2E_BASE_URL}/auth/signup" || true)
            if [ "$CODE" = "200" ] || [ "$CODE" = "409" ]; then
              echo "User seed complete (HTTP $CODE)"; exit 0
            fi
            echo "Signup not ready (HTTP $CODE). Retrying in 2s..."
            sleep 2
          done
          echo "Failed to create E2E user after retries"; exit 1
      
      - name: Diagnostics on failure
        if: failure()
        run: |
          echo "=== Cluster objects ==="
          kubectl -n $NAMESPACE get deploy,rs,po,svc -o wide || true
          echo "=== Events (recent) ==="
          kubectl -n $NAMESPACE get events --sort-by=.metadata.creationTimestamp | tail -n 100 || true
          
          echo "=== Describe deployments ==="
          for d in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            echo "--- describe deploy/$d ---"
            kubectl -n $NAMESPACE describe deploy/$d || true
          done
          
          echo "=== Describe pods by app label ==="
          for a in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            echo "--- describe pods app=$a ---"
            kubectl -n $NAMESPACE describe po -l app=$a || true
          done
          
          echo "=== Last logs (200 lines) for each app ==="
          for a in auth-service quizz-service quiz-generator-consumer evaluation-service rag-service; do
            echo "--- logs app=$a ---"
            kubectl -n $NAMESPACE logs -l app=$a --all-containers=true --tail=200 || true
          done
          
          echo "=== In-cluster curl to key endpoints ==="
          kubectl -n $NAMESPACE run curl --rm -i --image=curlimages/curl:8.5.0 --restart=Never -- \
            sh -lc '
              set -x
              for u in \
                auth-service:8001/openapi.json \
                quizz-service:8004/health \
                evaluation-service:8003/health \
                rag-service:8002/health \
              ; do
                echo ">>> GET http://$u"
                curl -sS --max-time 10 "http://$u" || true
                echo
              done
            ' || true

      - name: Export E2E_BASE_URL from Ingress
        run: echo "E2E_BASE_URL=$(minikube service -n ingress-nginx ingress-nginx-controller --url | head -n1)" >> $GITHUB_ENV

      - name: Run E2E tests
        env:
          E2E_BASE_URL: ${{ env.E2E_BASE_URL }}
          E2E_USERNAME: ${{ secrets.E2E_USERNAME }}
          E2E_PASSWORD: ${{ secrets.E2E_PASSWORD }}
        run: pytest -q tests/e2e -m e2e
